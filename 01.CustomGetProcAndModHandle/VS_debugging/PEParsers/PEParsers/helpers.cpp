/*
 Red Team Operator helper functions

 author: reenz0h (twitter: @SEKTOR7net)
 credits: zerosum0x0, speedi13

*/

#include "PEstructs.h"
#include "helpers.h"
#include <stdio.h>

typedef HMODULE(WINAPI* LoadLibrary_t)(LPCSTR lpFileName);
LoadLibrary_t pLoadLibraryA = NULL;



HMODULE WINAPI hlpGetModuleHandle(LPCWSTR sModuleName) {

	// get the offset of Process Environment Block
#ifdef _M_IX86 
	PEB* ProcEnvBlk = (PEB*)__readfsdword(0x30);
#else
	PEB* ProcEnvBlk = (PEB*)__readgsqword(0x60);
#endif

	// return base address of a calling module
	if (sModuleName == NULL)
		return (HMODULE)(ProcEnvBlk->ImageBaseAddress);// TIS IS FOR GETTING BASE IMAGE ADDRESS OF PEB 

	// HERE WE HAVE A PROPER HAMDLE 
	// WE ARE ABLE TO START PARSING 
	PEB_LDR_DATA* Ldr = ProcEnvBlk->Ldr;
	LIST_ENTRY* ModuleList = NULL;

	ModuleList = &Ldr->InMemoryOrderModuleList;
	LIST_ENTRY* pStartListEntry = ModuleList->Flink;

	// SIMPLE ITERATING LINKED LIST  
	for (LIST_ENTRY* pListEntry = pStartListEntry;  		// start from beginning of InMemoryOrderModuleList
		pListEntry != ModuleList;	    	// walk all list entries
		pListEntry = pListEntry->Flink) {

		// get current Data Table Entry
		LDR_DATA_TABLE_ENTRY* pEntry = (LDR_DATA_TABLE_ENTRY*)((BYTE*)pListEntry - sizeof(LIST_ENTRY));

		// check if module is found and return its base address
		if (lstrcmpiW(pEntry->BaseDllName.Buffer, sModuleName) == 0)
			return (HMODULE)pEntry->DllBase;
	}

	// otherwise:
	return NULL;

}

FARPROC WINAPI hlpGetProcAddress(HMODULE hMod, char* sProcName) {

	// it is taken as parameters from custom get module handle
	char* pBaseAddr = (char*)hMod;

	// get pointers to main headers/structures
	// extractiong all needed information from pe module EVERYTHING EXTRACTED FROM FIELDS BELOW ARE R V S !!
	// if we need virtual address we need to add base to virtual address 
	IMAGE_DOS_HEADER* pDosHdr = (IMAGE_DOS_HEADER*)pBaseAddr; // dosheader is located at base address so casting pointer to structure does the job
	IMAGE_NT_HEADERS* pNTHdr = (IMAGE_NT_HEADERS*)(pBaseAddr + pDosHdr->e_lfanew); // from dos header we can reach to e_lfanew which holds RVA of PE header (the new one with jucy information)  
	IMAGE_OPTIONAL_HEADER* pOptionalHdr = &pNTHdr->OptionalHeader;
	IMAGE_DATA_DIRECTORY* pExportDataDir = (IMAGE_DATA_DIRECTORY*)(&pOptionalHdr->DataDirectory[IMAGE_DIRECTORY_ENTRY_EXPORT]); // here we can finally reach export directory 
	IMAGE_EXPORT_DIRECTORY* pExportDirAddr = (IMAGE_EXPORT_DIRECTORY*)(pBaseAddr + pExportDataDir->VirtualAddress); // calculation of actual address of export dir 

	// resolve addresses to Export Address Table, table of function names and "table of ordinals"
	// EXPORT ADDRESS TABLE
	DWORD* pEAT = (DWORD*)(pBaseAddr + pExportDirAddr->AddressOfFunctions);
	// TABLE OF FUNCTION NAMES 
	DWORD* pFuncNameTbl = (DWORD*)(pBaseAddr + pExportDirAddr->AddressOfNames);
	// TABLE OF ORDINARS, HINTS, ODD NUMBERS 
	WORD* pHintsTbl = (WORD*)(pBaseAddr + pExportDirAddr->AddressOfNameOrdinals);

	// function address we're looking for !!
	void* pProcAddr = NULL;

	// HERE WE ARE STARTING TO PARSE. we can look by function name or its ordinar 
	// resolve function by ordinal case 1:
	if (((DWORD_PTR)sProcName >> 16) == 0) {
		WORD ordinal = (WORD)sProcName & 0xFFFF;	// convert to WORD by masking 
		DWORD Base = pExportDirAddr->Base;			// first ordinal number we need to check if ordinar is implemented in our dll 

		// check if ordinal is not out of scope
		if (ordinal < Base || ordinal >= Base + pExportDirAddr->NumberOfFunctions) // here calculations are to check if ordinar is in dll 
			return NULL;

		// get the function virtual address = RVA + BaseAddr
		pProcAddr = (FARPROC)(pBaseAddr + (DWORD_PTR)pEAT[ordinal - Base]); // jump to export address table directly, orfinar-base (like in building example) gives us address of function (RVA) 
	}
	// resolve function by name CASE 2:
	else {
		// parse through table of function names
		for (DWORD i = 0; i < pExportDirAddr->NumberOfNames; i++) {
			char* sTmpFuncName = (char*)pBaseAddr + (DWORD_PTR)pFuncNameTbl[i];

			if (strcmp(sProcName, sTmpFuncName) == 0) { // here in if we are COMPARING TWO STRINGS 
				// found, get the function virtual address = RVA + BaseAddr
				pProcAddr = (FARPROC)(pBaseAddr + (DWORD_PTR)pEAT[pHintsTbl[i]]);
				break;
			}
		}
	}
	// SUPERCASE 0 DEALING WITH FORWARDING 
	// check if found VA is forwarded to external library.function
	if ((char*)pProcAddr >= (char*)pExportDirAddr &&
		(char*)pProcAddr < (char*)(pExportDirAddr + pExportDataDir->Size)) {// JUST CHECKS IF FOUND RVA IS IN THE RANGE OF EXPORT DIRECTORY MAMORY REGION (SEE NOTES), IF IT IS THAT MEANS THAT OUR FUNCTION IS FORWARDED

		// WE KNOW OUR RVA, 
		// WE NEED TO EXTRACT  library.function string AS SEPARATE STRING 

		char* sFwdDLL = _strdup((char*)pProcAddr); 	// get a copy of library.function string, STORES LIBRARY NAME (STRING DUPLICATE FUNCTION) 
		if (!sFwdDLL) return NULL;

		// get external function name
		char* sFwdFunction = strchr(sFwdDLL, '.');// THIS FUNCTION STRCHR FIND THE FIND OCCURANCE OF THE DOT 
		*sFwdFunction = 0;					// set trailing null byte for external library name -> library\x0function
		sFwdFunction++;						// shift a pointer to the beginning of function name (BECOAUSE IT NOW PONTS TO ZERO BYTE NOT F LETTER) 

		// resolve LoadLibrary function pointer, keep it as global variable HERE IS RECURIVE CALL UNTIL LIB loadlibrarya IS FOUND 
		if (pLoadLibraryA == NULL) {
			pLoadLibraryA = (LoadLibrary_t)hlpGetProcAddress(hlpGetModuleHandle(L"KERNEL32.DLL"), (char*)"LoadLibraryA");
			if (pLoadLibraryA == NULL) return NULL;
		}

		// load the external library LOAD DESIRED LIBRARY 
		HMODULE hFwd = pLoadLibraryA(sFwdDLL);
		free(sFwdDLL);							// release the allocated memory for lib.func string copy
		if (!hFwd) return NULL;

		// get the address of function the original call is forwarded to
		pProcAddr = hlpGetProcAddress(hFwd, sFwdFunction);
	}

	return (FARPROC)pProcAddr;
}
